var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "chokidar", "./logMessages", "lodash", "./FileUtils", "./snClient", "./appUtils", "./genericUtils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const chokidar_1 = __importDefault(require("chokidar"));
    const logMessages_1 = require("./logMessages");
    const lodash_1 = require("lodash");
    const FileUtils_1 = require("./FileUtils");
    const snClient_1 = require("./snClient");
    const appUtils_1 = require("./appUtils");
    const genericUtils_1 = require("./genericUtils");
    const DEBOUNCE_MS = 300;
    let pushQueue = [];
    let watcher = undefined;
    const processQueue = lodash_1.debounce(async () => {
        const snClient = snClient_1.defaultClient();
        if (pushQueue.length > 0) {
            //dedupe pushes
            const toProcess = Array.from(new Set([...pushQueue]));
            pushQueue = [];
            const fileContexts = toProcess
                .map(FileUtils_1.getFileContextFromPath)
                .filter((ctx) => !!ctx);
            const buildPromises = fileContexts.map(ctx => {
                const { targetField } = ctx;
                const fieldMap = { [targetField]: ctx };
                return appUtils_1.buildRec(fieldMap);
            });
            const builds = await genericUtils_1.allSettled(buildPromises);
            const updatePromises = builds.map(async (buildRes, index) => {
                const { tableName, sys_id, name } = fileContexts[index];
                if (buildRes.status === "rejected") {
                    return {
                        success: false,
                        message: buildRes.reason.message || "Failed to build"
                    };
                }
                try {
                    const response = await snClient.updateRecord(tableName, sys_id, buildRes.value);
                    return snClient_1.processPushResponse(response, appUtils_1.summarizeRecord(tableName, name));
                }
                catch (e) {
                    return { success: false, message: e.message || "Failed to update" };
                }
            });
            const updateResults = await Promise.all(updatePromises);
            updateResults.forEach((res, index) => {
                logMessages_1.logFilePush(fileContexts[index], res);
            });
        }
    }, DEBOUNCE_MS);
    function startWatching(directory) {
        watcher = chokidar_1.default.watch(directory);
        watcher.on("change", fileChanged);
    }
    exports.startWatching = startWatching;
    async function fileChanged(path) {
        pushQueue.push(path);
        processQueue();
    }
    function stopWatching() {
        if (watcher) {
            watcher.close();
        }
    }
    exports.stopWatching = stopWatching;
});
