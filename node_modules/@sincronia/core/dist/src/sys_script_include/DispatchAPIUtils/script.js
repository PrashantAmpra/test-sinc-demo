"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DispatchAPIUtils = /*#__PURE__*/function () {
  function DispatchAPIUtils() {
    _classCallCheck(this, DispatchAPIUtils);
  }

  _createClass(DispatchAPIUtils, null, [{
    key: "isValidCallById",
    value: function isValidCallById(callId) {
      var callGR = new GlideRecord('x_nuvo_csd_call');
      var validCall = callGR.get(callId);

      if (!validCall) {
        return false;
      }

      var callEscalated = callGR.getValue('work_order') != null;

      if (!callEscalated) {
        return false;
      }

      return true;
    }
  }, {
    key: "checkWorkOrder",
    value: function checkWorkOrder(woGr) {
      var workOrderCheck = {
        warnings: [],
        errors: []
      };

      var addToastMessage = function addToastMessage(type, message) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        workOrderCheck[type].push(_objectSpread(_objectSpread({}, options), {}, {
          message: message
        }));
      };

      var addErrorMsg = function addErrorMsg(msg, options) {
        addToastMessage('errors', msg, options);
      };

      var addWarningMsg = function addWarningMsg(msg, options) {
        addToastMessage('warnings', msg, options);
      };

      dispatchCheckWorkOrder(woGr, addErrorMsg, addWarningMsg);
      return workOrderCheck;
    }
  }, {
    key: "getWorkOrderMetadata",
    value: function getWorkOrderMetadata(woGR) {
      var details = {
        number: woGR.getValue('number') || '',
        shortDescription: woGR.getValue('short_description') || ''
      };
      return details;
    }
  }, {
    key: "generateActiveEvent",
    value: function generateActiveEvent(workOrderGR, apptGR) {
      var _x_nuvo_eam = x_nuvo_eam,
          dayjs = _x_nuvo_eam.dayjs;
      var workOrderId = workOrderGR.getValue('sys_id') || '';
      var nuvoProp = new x_nuvo_mobile.NuvoloProperties();
      var primaryLabelProp = nuvoProp.getProperty('appointment_primary_display_field', 'Dispatch') || 'short_description';
      var primaryLabel = workOrderGR.getElement(primaryLabelProp).getDisplayValue();
      var secondaryLabelProp = nuvoProp.getProperty('appointment_secondary_display_field', 'Dispatch') || 'priority';
      var secondaryLabel = workOrderGR.getElement(secondaryLabelProp).getDisplayValue();
      var location = DispatchScheduleUtils().getLocationFromWorkOrder(workOrderId);

      var _DispatchScheduleUtil = DispatchScheduleUtils().checkForWarnings(location),
          baseLabels = _DispatchScheduleUtil.labels,
          baseWarning = _DispatchScheduleUtil.warning;

      var activeEventBase = {
        primaryLabel: primaryLabel,
        secondaryLabel: secondaryLabel,
        workOrder: workOrderId,
        location: location,
        assignedToId: undefined,
        warning: baseWarning,
        warningLabels: baseLabels
      };

      if (apptGR) {
        var _DispatchScheduleUtil2 = DispatchScheduleUtils().checkForWarnings(location),
            warning = _DispatchScheduleUtil2.warning,
            warningLabels = _DispatchScheduleUtil2.labels;

        var _start = x_nuvo_eam.DateUtils.SNDateTimeToUTC(apptGR.getValue('event_start') || '');

        var _end = x_nuvo_eam.DateUtils.SNDateTimeToUTC(apptGR.getValue('event_end') || '');

        var _state = '0';
        return _objectSpread(_objectSpread({}, activeEventBase), {}, {
          warning: warning,
          warningLabels: warningLabels,
          start: _start,
          end: _end,
          state: _state,
          sys_id: apptGR.getValue('sys_id') || undefined,
          fixed: false,
          title: apptGR.getValue('title') || '',
          assignedToId: apptGR.getValue('participant') || undefined
        });
      }

      var grPlannedStart = workOrderGR.getValue('planned_start');
      var startGDT = grPlannedStart ? new GlideDateTime(grPlannedStart) : new GlideDateTime();
      var durationProp = parseInt(nuvoProp.getProperty('default_appointment_duration', 'Dispatch') || '1', 10);
      var intervalProp = parseInt(nuvoProp.getProperty('proposal_resolution', 'Dispatch') || '1', 10);
      var startNumeric = startGDT.getNumericValue();
      var adjustedStartMS = DispatchDataHelper.roundToNearest(intervalProp, startNumeric);
      var start = dayjs(adjustedStartMS).format();
      var end = dayjs(adjustedStartMS).add(durationProp, 'second').format();
      var state = '0';
      return _objectSpread(_objectSpread({}, activeEventBase), {}, {
        start: start,
        end: end,
        state: state,
        fixed: false,
        title: primaryLabel,
        sys_id: '-1'
      });
    }
  }, {
    key: "getDisplayDate",
    value: function getDisplayDate(apptGR, workOrderGr) {
      var _x_nuvo_eam2 = x_nuvo_eam,
          DateUtils = _x_nuvo_eam2.DateUtils,
          dayjs = _x_nuvo_eam2.dayjs;

      if (apptGR) {
        var apptStart = apptGR.getValue('event_start') || '';
        return DateUtils.SNDateTimeToUTC(apptStart);
      }

      var woPlannedStart = workOrderGr.getValue('planned_start');

      if (woPlannedStart) {
        return DateUtils.SNDateTimeToUTC(woPlannedStart);
      }

      return dayjs().utcOffset(new GlideDateTime().getTZOffset() / 3600000).utc().format();
    }
  }, {
    key: "getCallRecord",
    value: function getCallRecord(taskId) {
      if (!DispatchAPIUtils.isValidCallById(taskId)) {
        throw new Error('Invalid Call or no Work Order assigned to Call');
      }

      var callGR = new GlideRecord('x_nuvo_csd_call');

      if (!callGR.get(taskId)) {
        throw new Error('Failed to get the call! Invalid ID');
      }

      if (!callGR.getValue('work_order')) {
        throw new Error('No work order!');
      }

      return callGR;
    }
  }, {
    key: "getParticipants",
    value: function getParticipants(techs, woGR) {
      var participants = techs.map(function (tech) {
        return {
          sys_id: tech.userId,
          table: 'sys_user'
        };
      });

      if (woGR.getValue('asset')) {
        var assetGR = woGR.asset.getRefRecord();
        participants.push({
          sys_id: assetGR.getValue('sys_id') || '',
          table: assetGR.getValue('sys_class_name') || ''
        });
      }

      return participants;
    }
  }, {
    key: "removeProposedData",
    value: function removeProposedData(initialScheduleMap, apptGR) {
      var strippedScheduleMap = _objectSpread({}, initialScheduleMap);

      if (apptGR) {
        var childGR = new GlideRecord('x_nuvo_csd_appointment');
        childGR.addQuery('parent', apptGR.getValue('sys_id'));
        childGR.query();
        var table = apptGR.getValue('participant_table') || '';
        var participantId = apptGR.getValue('participant') || '';
        var apptId = apptGR.getValue('sys_id') || '';
        strippedScheduleMap = DispatchDataHelper.removeFromApptMap(table, participantId, apptId, initialScheduleMap);

        while (childGR.next()) {
          strippedScheduleMap = DispatchDataHelper.removeFromApptMap(childGR.getValue('participant_table') || '', childGR.getValue('participant') || '', childGR.getValue('sys_id') || '', strippedScheduleMap);
        }
      }

      return strippedScheduleMap;
    }
  }, {
    key: "getScheduleData",
    value: function getScheduleData(opts) {
      var taskId = opts.taskId,
          rangeStart = opts.rangeStart,
          rangeEnd = opts.rangeEnd,
          participants = opts.participants;
      var callGR = this.getCallRecord(taskId);
      var woGR = callGR.work_order.getRefRecord();
      var workOrderId = woGR.getValue('sys_id') || '';
      var apptGR = new DispatchDataHelper().retrieveAppointment(workOrderId) || undefined;
      var initialScheduleMap = DispatchScheduleUtils().getSchedules({
        rangeEnd: rangeEnd,
        rangeStart: rangeStart,
        participants: participants
      });
      var strippedScheduleMap = this.removeProposedData(initialScheduleMap, apptGR);
      return strippedScheduleMap;
    }
  }, {
    key: "getWorkOrder",
    value: function getWorkOrder(idType, taskId) {
      if (idType === 'call') {
        var callGR = this.getCallRecord(taskId);

        var _woGR = callGR.work_order.getRefRecord();

        return _woGR;
      }

      var woGR = new GlideRecord('x_nuvo_eam_work_order');

      if (woGR.get(taskId)) {
        return woGR;
      }

      throw new Error('Failed to find work order record!');
    }
  }, {
    key: "getTechs",
    value: function getTechs(woGR) {
      var nuvoProps = new x_nuvo_mobile.NuvoloProperties();
      var techLimit = parseInt(nuvoProps.getProperty('technician_page_size', 'Dispatch') || '0', 10);
      var routingUtils = new TaskRoutingRuleUtils();
      var techs = routingUtils.getAllTechsRouted(woGR.getValue('sys_id') || '').sort(function (techA, techB) {
        return techB.weight - techA.weight;
      });
      var recommendedTechs = techs.filter(function (tech) {
        return tech.recommended;
      });

      if (recommendedTechs.length >= techLimit) {
        return recommendedTechs.slice(0, techLimit);
      }

      var remaining = techLimit - recommendedTechs.length;
      var additionalTechs = techs.filter(function (tech) {
        return !tech.recommended;
      }).slice(0, remaining);
      return [].concat(_toConsumableArray(recommendedTechs), _toConsumableArray(additionalTechs));
    }
  }, {
    key: "getUserHomeBase",
    value: function getUserHomeBase(userGR) {
      try {
        var buildingGR = userGR.x_nuvo_eam_primary_location.getRefRecord().site.getRefRecord();
        return {
          latitude: buildingGR.getValue('latitude'),
          longitude: buildingGR.getValue('longitude')
        };
      } catch (e) {
        return {
          latitude: null,
          longitude: null
        };
      }
    }
  }, {
    key: "genStatusUserMetadata",
    value: function genStatusUserMetadata(id) {
      var userGR = new GlideRecord('sys_user');
      var base = {
        // TODO: replace default name with some kind of message i18n
        name: 'unknown',
        table: 'sys_user',
        recommended: true,
        weight: 0,
        homeBase: {
          latitude: null,
          longitude: null
        }
      };

      if (userGR.get(id)) {
        return _objectSpread(_objectSpread({}, base), {}, {
          name: userGR.getDisplayValue(),
          homeBase: DispatchAPIUtils.getUserHomeBase(userGR)
        });
      }

      return base;
    }
  }, {
    key: "getMetadata",
    value: function getMetadata(participant) {
      var table = participant.table,
          sys_id = participant.sys_id;

      if (table === 'sys_user') {
        return DispatchAPIUtils.genStatusUserMetadata(sys_id);
      }

      return {
        name: 'TESTING',
        table: table,
        description: 'NOT SUPPORTED YET'
      };
    }
  }, {
    key: "getAllMetadata",
    value: function getAllMetadata(participants) {
      return participants.reduce(function (acc, participant) {
        var table = participant.table,
            sys_id = participant.sys_id;
        var tableSection = acc[table] || {};
        var md = DispatchAPIUtils.getMetadata(participant);

        var updatedTableSection = _objectSpread(_objectSpread({}, tableSection), {}, _defineProperty({}, sys_id, md));

        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, table, updatedTableSection));
      }, {
        sys_user: {}
      });
    }
  }, {
    key: "participantsFromTeams",
    value: function participantsFromTeams(teamMap) {
      return Object.keys(teamMap).reduce(function (acc, teamId) {
        var teamObj = teamMap[teamId];
        var participants = teamObj.members.map(function (member) {
          return {
            table: 'sys_user',
            sys_id: member.sys_id
          };
        });
        return [].concat(_toConsumableArray(acc), _toConsumableArray(participants));
      }, []);
    }
  }, {
    key: "statusInitialLoad",
    value: function statusInitialLoad(args) {
      var rangeEnd = args.rangeEnd,
          rangeStart = args.rangeStart;
      var teamData = FieldServiceTeamUtils.getTeamInfoFromUser(gs.getUserID());
      var participants = DispatchAPIUtils.participantsFromTeams(teamData);
      var scheduleEvents = DispatchScheduleUtils().getSchedules({
        rangeStart: rangeStart,
        rangeEnd: rangeEnd,
        participants: participants
      });
      var scheduleMetadata = DispatchAPIUtils.getAllMetadata(participants);
      var liveLocations = LocationUtils().getLocationsForUsers(participants.map(function (p) {
        return p.sys_id;
      }));
      return {
        scheduleEvents: scheduleEvents,
        scheduleMetadata: scheduleMetadata,
        teamData: teamData,
        liveLocations: liveLocations
      };
    }
  }, {
    key: "getAssignmentDataInitialLoad",
    value: function getAssignmentDataInitialLoad(idType, taskId) {
      var _x_nuvo_eam3 = x_nuvo_eam,
          dayjs = _x_nuvo_eam3.dayjs,
          DateUtils = _x_nuvo_eam3.DateUtils;
      var woGR = DispatchAPIUtils.getWorkOrder(idType, taskId);
      var workOrderChecks = DispatchAPIUtils.checkWorkOrder(woGR);
      var workOrderMetadata = DispatchAPIUtils.getWorkOrderMetadata(woGR);
      var homeBaseThreshold = parseInt(new x_nuvo_mobile.NuvoloProperties().getProperty('home_base_threshold', 'Dispatch') || '8', 10);
      var techs = DispatchAPIUtils.getTechs(woGR);
      var techMetadata = techs.reduce(function (metadata, tech) {
        var userId = tech.userId,
            recommended = tech.recommended,
            weight = tech.weight,
            name = tech.name,
            homeBase = tech.homeBase;

        var md = _objectSpread(_objectSpread({}, metadata), {}, _defineProperty({}, userId, {
          recommended: recommended,
          weight: weight,
          name: name,
          homeBase: homeBase,
          table: 'sys_user'
        }));

        return md;
      }, {});
      var assetMetadata = {};
      var participants = this.getParticipants(techs, woGR);

      if (woGR.getValue('asset')) {
        var assetGR = woGR.asset.getRefRecord();
        assetMetadata[assetGR.getValue('sys_id') || ''] = {
          name: assetGR.getDisplayValue(),
          table: assetGR.getValue('sys_class_name') || '',
          description: "".concat(assetGR.asset_manufacturer.getDisplayValue(), " - ").concat(assetGR.model_name.getDisplayValue())
        };
      }

      var workOrderId = woGR.getValue('sys_id') || '';
      var apptGR = new DispatchDataHelper().retrieveAppointment(workOrderId);
      var displayDate = DispatchAPIUtils.getDisplayDate(apptGR, woGR);
      var rangeStart = dayjs.utc(DateUtils.sanitizeUTCForDayJS(displayDate)).utcOffset(new GlideDateTime().getTZOffset() / 3600000).startOf('day').utc().format();
      var rangeEnd = dayjs.utc(DateUtils.sanitizeUTCForDayJS(rangeStart)).add(1, 'day').format();
      var scheduleMap = DispatchScheduleUtils().getSchedules({
        rangeEnd: rangeEnd,
        rangeStart: rangeStart,
        participants: participants
      });
      var schedulerData = this.removeProposedData(scheduleMap, apptGR || undefined);
      var activeEvent = DispatchAPIUtils.generateActiveEvent(woGR, apptGR);
      return {
        activeEvent: activeEvent,
        assetMetadata: assetMetadata,
        techMetadata: techMetadata,
        workOrderChecks: workOrderChecks,
        workOrderMetadata: workOrderMetadata,
        homeBaseThreshold: homeBaseThreshold,
        schedulerData: schedulerData,
        displayDate: displayDate
      };
    }
  }]);

  return DispatchAPIUtils;
}();