var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "path", "progress", "./FileUtils", "./server", "./config", "./constants", "./PluginManager", "./snClient", "./Logger", "./genericUtils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const path_1 = __importDefault(require("path"));
    const progress_1 = __importDefault(require("progress"));
    const fUtils = __importStar(require("./FileUtils"));
    const SNClient = __importStar(require("./server"));
    const config_1 = __importDefault(require("./config"));
    const constants_1 = require("./constants");
    const PluginManager_1 = __importDefault(require("./PluginManager"));
    const snClient_1 = require("./snClient");
    const Logger_1 = require("./Logger");
    const genericUtils_1 = require("./genericUtils");
    const processFilesInManRec = async (recPath, rec, forceWrite) => {
        const fileWrite = fUtils.writeSNFileCurry(forceWrite);
        const filePromises = rec.files.map(file => fileWrite(file, recPath));
        await Promise.all(filePromises);
        // Side effect, remove content from files so it doesn't get written to manifest
        rec.files.forEach(file => {
            delete file.content;
        });
    };
    const processRecsInManTable = async (tablePath, table, forceWrite) => {
        const { records } = table;
        const recKeys = Object.keys(records);
        const recKeyToPath = (key) => path_1.default.join(tablePath, records[key].name);
        const recPathPromises = recKeys
            .map(recKeyToPath)
            .map(fUtils.createDirRecursively);
        await Promise.all(recPathPromises);
        const filePromises = recKeys.reduce((acc, recKey) => {
            return [
                ...acc,
                processFilesInManRec(recKeyToPath(recKey), records[recKey], forceWrite)
            ];
        }, []);
        return Promise.all(filePromises);
    };
    const processTablesInManifest = async (tables, forceWrite) => {
        const tableNames = Object.keys(tables);
        const tablePromises = tableNames.map(tableName => {
            return processRecsInManTable(path_1.default.join(config_1.default.getSourcePath(), tableName), tables[tableName], forceWrite);
        });
        await Promise.all(tablePromises);
    };
    exports.processManifest = async (manifest, forceWrite = false) => {
        await processTablesInManifest(manifest.tables, forceWrite);
        await fUtils.writeFileForce(config_1.default.getManifestPath(), JSON.stringify(manifest, null, 2));
    };
    const markFileMissing = (missingObj) => (table) => (recordId) => (file) => {
        if (!missingObj[table]) {
            missingObj[table] = {};
        }
        if (!missingObj[table][recordId]) {
            missingObj[table][recordId] = [];
        }
        const { name, type } = file;
        missingObj[table][recordId].push({ name, type });
    };
    const markRecordMissing = (record, missingFunc) => {
        record.files.forEach(file => {
            missingFunc(record.sys_id)(file);
        });
    };
    const markTableMissing = (table, tableName, missingFunc) => {
        Object.keys(table.records).forEach(recName => {
            markRecordMissing(table.records[recName], missingFunc(tableName));
        });
    };
    const checkFilesForMissing = async (recPath, files, missingFunc) => {
        const checkPromises = files.map(fUtils.SNFileExists(recPath));
        const checks = await Promise.all(checkPromises);
        checks.forEach((check, index) => {
            if (!check) {
                missingFunc(files[index]);
            }
        });
    };
    const checkRecordsForMissing = async (tablePath, records, missingFunc) => {
        const recNames = Object.keys(records);
        const recPaths = recNames.map(fUtils.appendToPath(tablePath));
        const checkPromises = recNames.map((recName, index) => fUtils.pathExists(recPaths[index]));
        const checks = await Promise.all(checkPromises);
        const fileCheckPromises = checks.map(async (check, index) => {
            const recName = recNames[index];
            const record = records[recName];
            if (!check) {
                markRecordMissing(record, missingFunc);
                return;
            }
            await checkFilesForMissing(recPaths[index], record.files, missingFunc(record.sys_id));
        });
        await Promise.all(fileCheckPromises);
    };
    const checkTablesForMissing = async (topPath, tables, missingFunc) => {
        const tableNames = Object.keys(tables);
        const tablePaths = tableNames.map(fUtils.appendToPath(topPath));
        const checkPromises = tableNames.map((tableName, index) => fUtils.pathExists(tablePaths[index]));
        const checks = await Promise.all(checkPromises);
        const recCheckPromises = checks.map(async (check, index) => {
            const tableName = tableNames[index];
            if (!check) {
                markTableMissing(tables[tableName], tableName, missingFunc);
                return;
            }
            await checkRecordsForMissing(tablePaths[index], tables[tableName].records, missingFunc(tableName));
        });
        await Promise.all(recCheckPromises);
    };
    exports.findMissingFiles = async (manifest) => {
        const missing = {};
        const { tables } = manifest;
        const missingTableFunc = markFileMissing(missing);
        await checkTablesForMissing(config_1.default.getSourcePath(), tables, missingTableFunc);
        // missing gets mutated along the way as things get processed
        return missing;
    };
    exports.processMissingFiles = async (newManifest) => {
        try {
            const missing = await exports.findMissingFiles(newManifest);
            const filesToProcess = await SNClient.getMissingFiles(missing);
            await processTablesInManifest(filesToProcess, false);
        }
        catch (e) {
            throw e;
        }
    };
    exports.getAppFilesInPath = async (path) => {
        const filePaths = await fUtils.getPathsInPath(path);
        const fileCtxPromises = filePaths.map(fUtils.getFileContextFromPath);
        const maybeFileContexts = await Promise.all(fileCtxPromises);
        const fileContexts = maybeFileContexts.filter((ctx) => ctx !== undefined);
        return fileContexts;
    };
    const getAppFilesInPaths = async (paths) => {
        const appFilePromises = paths.map(exports.getAppFilesInPath);
        const appFileLists = await Promise.all(appFilePromises);
        return appFileLists.flat();
    };
    const countRecsInTree = (tree) => {
        return Object.keys(tree).reduce((acc, table) => {
            return acc + Object.keys(tree[table]).length;
        }, 0);
    };
    exports.groupAppFiles = (fileCtxs) => {
        const fillIfNotExists = (rec, key) => {
            if (!rec[key]) {
                rec[key] = {};
            }
        };
        return fileCtxs.reduce((tree, cur) => {
            const { tableName, sys_id, targetField } = cur;
            fillIfNotExists(tree, tableName);
            fillIfNotExists(tree[tableName], sys_id);
            tree[tableName][sys_id][targetField] = cur;
            return tree;
        }, {});
    };
    exports.buildRec = async (rec) => {
        const fields = Object.keys(rec);
        const buildPromises = fields.map(field => {
            return PluginManager_1.default.getFinalFileContents(rec[field]);
        });
        const builtFiles = await genericUtils_1.allSettled(buildPromises);
        const buildSuccess = !builtFiles.find(buildRes => buildRes.status === "rejected");
        if (!buildSuccess) {
            throw new Error(genericUtils_1.aggregateErrorMessages(builtFiles
                .filter((b) => b.status === "rejected")
                .map(b => b.reason), "Failed to build!", (_, index) => `${index}`));
        }
        return builtFiles.reduce((acc, buildRes, index) => {
            const { value: content } = buildRes;
            const fieldName = fields[index];
            return { ...acc, [fieldName]: content };
        }, {});
    };
    exports.summarizeRecord = (table, recDescriptor) => `${table} > ${recDescriptor}`;
    const buildAndPush = async (table, tableTree, tick) => {
        const recIds = Object.keys(tableTree);
        const buildPromises = recIds.map(sysId => exports.buildRec(tableTree[sysId]));
        const builtRecs = await genericUtils_1.allSettled(buildPromises);
        const client = snClient_1.defaultClient();
        const pushPromises = builtRecs.map(async (buildRes, index) => {
            const recMap = tableTree[recIds[index]];
            const recFields = Object.keys(recMap);
            const recDesc = recMap[recFields[0]].name || recIds[index];
            const recSummary = exports.summarizeRecord(table, recDesc);
            if (buildRes.status === "rejected") {
                return {
                    success: false,
                    message: `${recSummary} : ${buildRes.reason.message}`
                };
            }
            try {
                const res = await snClient_1.retryOnErr(() => client.updateRecord(table, recIds[index], buildRes.value), constants_1.PUSH_RETRY_LIMIT, constants_1.PUSH_RETRY_WAIT, (numTries) => {
                    Logger_1.logger.debug(`Failed to push ${recSummary}! Retrying with ${numTries} left...`);
                });
                return snClient_1.processPushResponse(res, recSummary);
            }
            catch (e) {
                const errMsg = e.message || "Too many retries";
                return { success: false, message: `${recSummary} : ${errMsg}` };
            }
            finally {
                // this block always runs, even if we return
                if (tick) {
                    tick();
                }
            }
        });
        const pushResults = await Promise.all(pushPromises);
        return pushResults;
    };
    const getProgTick = (logLevel, total) => {
        if (logLevel === "info") {
            const progBar = new progress_1.default(":bar :current/:total (:percent)", {
                total,
                width: 60
            });
            return () => {
                progBar.tick();
            };
        }
        // no-op at other log levels
        return undefined;
    };
    exports.getValidPaths = async (encodedPaths) => {
        const pathChunks = encodedPaths
            .split(constants_1.PATH_DELIMITER)
            .filter(p => p && p !== "");
        const pathExistsPromises = pathChunks.map(fUtils.pathExists);
        const pathExistsCheck = await Promise.all(pathExistsPromises);
        return pathChunks.filter((_, index) => pathExistsCheck[index]);
    };
    exports.getFileTreeAndCount = async (encodedPaths) => {
        const validPaths = await exports.getValidPaths(encodedPaths);
        const appFileCtxs = await getAppFilesInPaths(validPaths);
        const appFileTree = exports.groupAppFiles(appFileCtxs);
        const recordCount = countRecsInTree(appFileTree);
        return [appFileTree, recordCount];
    };
    exports.pushFiles = async (appFileTree, recordCount) => {
        const tick = getProgTick(Logger_1.logger.getLogLevel(), recordCount);
        const buildAndPushPromises = Object.keys(appFileTree).map(table => buildAndPush(table, appFileTree[table], tick));
        const tablePushResults = await Promise.all(buildAndPushPromises);
        return tablePushResults.flat();
    };
});
