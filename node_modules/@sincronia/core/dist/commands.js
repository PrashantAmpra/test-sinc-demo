var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./config", "./Watcher", "./AppManager", "./appUtils", "./wizard", "./Logger", "./logMessages", "./server"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const config_1 = __importDefault(require("./config"));
    const Watcher_1 = require("./Watcher");
    const AppManager_1 = __importDefault(require("./AppManager"));
    const AppUtils = __importStar(require("./appUtils"));
    const wizard_1 = require("./wizard");
    const Logger_1 = require("./Logger");
    const logMessages_1 = require("./logMessages");
    const server_1 = require("./server");
    async function scopeCheck(successFunc, swapScopes = false) {
        try {
            const scopeCheck = await AppManager_1.default.checkScope(swapScopes);
            if (!scopeCheck.match) {
                logMessages_1.scopeCheckMessage(scopeCheck);
                // Throw exception to register this as an error
                throw new Error();
            }
            else {
                successFunc();
            }
        }
        catch (e) {
            Logger_1.logger.error("Failed to check your scope! You may want to make sure your project is configured correctly or run `npx sinc init`");
            // Throw exception to register this as an error
            process.exit(1);
        }
    }
    function setLogLevel(args) {
        Logger_1.logger.setLogLevel(args.logLevel);
    }
    async function devCommand(args) {
        setLogLevel(args);
        scopeCheck(async () => {
            Watcher_1.startWatching(config_1.default.getSourcePath());
            logMessages_1.devModeLog();
            let refresher = () => {
                refreshCommand(args, false);
            };
            let interval = config_1.default.getRefresh();
            if (interval && interval > 0) {
                Logger_1.logger.info(`Checking for new manifest files every ${interval} seconds`);
                setInterval(refresher, interval * 1000);
            }
        });
    }
    exports.devCommand = devCommand;
    async function refreshCommand(args, log = true) {
        setLogLevel(args);
        scopeCheck(async () => {
            try {
                if (!log)
                    setLogLevel({ logLevel: "warn" });
                await AppManager_1.default.syncManifest();
                setLogLevel(args);
            }
            catch (e) {
                throw e;
            }
        });
    }
    exports.refreshCommand = refreshCommand;
    async function pushCommand(args) {
        setLogLevel(args);
        scopeCheck(async () => {
            try {
                const { updateSet, ci, target, diff } = args;
                // Does not create update set if updateSetName is blank
                await AppManager_1.default.createAndAssignUpdateSet(updateSet, ci);
                const getEncodedPaths = async () => {
                    if (target !== undefined && target !== "") {
                        return target;
                    }
                    if (diff !== "") {
                        return AppManager_1.default.gitDiff(diff);
                    }
                    return config_1.default.getSourcePath();
                };
                const encodedPaths = await getEncodedPaths();
                const [fileTree, count] = await AppUtils.getFileTreeAndCount(encodedPaths);
                Logger_1.logger.info(`${count} files to push.`);
                let canPush = true;
                if (!ci) {
                    canPush = await AppManager_1.default.canPush();
                }
                if (!canPush) {
                    return;
                }
                const pushResults = await AppUtils.pushFiles(fileTree, count);
                logMessages_1.logPushResults(pushResults);
            }
            catch (e) {
                process.exit(1);
            }
        }, args.scopeSwap);
    }
    exports.pushCommand = pushCommand;
    async function downloadCommand(args) {
        setLogLevel(args);
        try {
            await AppManager_1.default.downloadWithFiles(args.scope);
        }
        catch (e) {
            throw e;
        }
    }
    exports.downloadCommand = downloadCommand;
    async function initCommand(args) {
        setLogLevel(args);
        try {
            await wizard_1.startWizard();
        }
        catch (e) {
            throw e;
        }
    }
    exports.initCommand = initCommand;
    async function buildCommand(args) {
        setLogLevel(args);
        try {
            if (args.diff !== "") {
                let files = await AppManager_1.default.gitDiff(args.diff);
                AppManager_1.default.writeDiff(files);
            }
            await AppManager_1.default.buildFiles();
        }
        catch (e) {
            throw e;
        }
    }
    exports.buildCommand = buildCommand;
    async function deployCommand(args) {
        setLogLevel(args);
        try {
            await AppManager_1.default.deployFiles();
        }
        catch (e) {
            throw e;
        }
    }
    exports.deployCommand = deployCommand;
    async function statusCommand() {
        try {
            let scopeObj = await server_1.getCurrentScope();
            Logger_1.logger.info(`Instance: ${process.env.SN_INSTANCE}`);
            Logger_1.logger.info(`Scope: ${scopeObj.scope}`);
            Logger_1.logger.info(`User: ${process.env.SN_USER}`);
        }
        catch (e) {
            throw e;
        }
    }
    exports.statusCommand = statusCommand;
});
