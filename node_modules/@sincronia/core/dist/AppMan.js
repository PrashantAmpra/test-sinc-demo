var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./FileUtils", "path", "./config"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findMissingFiles = exports.processManifest = void 0;
    const FileUtils_1 = require("./FileUtils");
    const path_1 = __importDefault(require("path"));
    const config_1 = __importDefault(require("./config"));
    const processFilesInManRec = async (recPath, rec) => {
        const filePromises = rec.files.map(file => FileUtils_1.writeSNFileIfNotExists(file, recPath));
        await Promise.all(filePromises);
        // Side effect, remove content from files so it doesn't get written to manifest
        rec.files.forEach(file => {
            delete file.content;
        });
    };
    const processRecsInManTable = async (tablePath, table) => {
        const { records } = table;
        const recKeys = Object.keys(records);
        const recKeyToPath = (key) => path_1.default.join(tablePath, records[key].name);
        const recPathPromises = recKeys.map(recKeyToPath).map(FileUtils_1.createDirRecursively);
        await Promise.all(recPathPromises);
        const filePromises = recKeys.reduce((acc, recKey) => {
            return [
                ...acc,
                processFilesInManRec(recKeyToPath(recKey), records[recKey])
            ];
        }, []);
        return Promise.all(filePromises);
    };
    const processTablesInManifest = async (manifest) => {
        const { tables } = manifest;
        const tableNames = Object.keys(tables);
        const tablePromises = tableNames.map(tableName => {
            return processRecsInManTable(path_1.default.join(config_1.default.getSourcePath(), tableName), tables[tableName]);
        });
        await Promise.all(tablePromises);
    };
    exports.processManifest = async (manifest) => {
        await processTablesInManifest(manifest);
        await FileUtils_1.writeFileForce(config_1.default.getManifestPath(), JSON.stringify(manifest, null, 2));
    };
    const markFileMissing = (missingObj) => (table) => (recordId) => (file) => {
        if (!missingObj[table]) {
            missingObj[table] = {};
        }
        if (!missingObj[table][recordId]) {
            missingObj[table][recordId] = [];
        }
        const { name, type } = file;
        missingObj[table][recordId].push({ name, type });
    };
    const markRecordMissing = (record, missingFunc) => {
        record.files.forEach(file => {
            missingFunc(record.sys_id)(file);
        });
    };
    const markTableMissing = (table, tableName, missingFunc) => {
        Object.keys(table.records).forEach(recName => {
            markRecordMissing(table.records[recName], missingFunc(tableName));
        });
    };
    const checkFilesForMissing = async (recPath, files, missingFunc) => {
        const checkPromises = files.map(FileUtils_1.SNFileExists(recPath));
        const checks = await Promise.all(checkPromises);
        checks.forEach((check, index) => {
            if (!check) {
                missingFunc(files[index]);
            }
        });
    };
    const checkRecordsForMissing = async (tablePath, records, missingFunc) => {
        const recNames = Object.keys(records);
        const recPaths = recNames.map(FileUtils_1.appendToPath(tablePath));
        const checkPromises = recNames.map((recName, index) => FileUtils_1.pathExists(recPaths[index]));
        const checks = await Promise.all(checkPromises);
        checks.forEach((check, index) => {
            const recName = recNames[index];
            const record = records[recName];
            if (!check) {
                markRecordMissing(record, missingFunc);
                return;
            }
            checkFilesForMissing(recPaths[index], record.files, missingFunc(record.sys_id));
        });
    };
    const checkTablesForMissing = async (topPath, tables, missingFunc) => {
        const tableNames = Object.keys(tables);
        const tablePaths = tableNames.map(FileUtils_1.appendToPath(topPath));
        const checkPromises = tableNames.map((tableName, index) => FileUtils_1.pathExists(tablePaths[index]));
        const checks = await Promise.all(checkPromises);
        checks.forEach((check, index) => {
            const tableName = tableNames[index];
            if (!check) {
                markTableMissing(tables[tableName], tableName, missingFunc);
                return;
            }
            checkRecordsForMissing(tablePaths[index], tables[tableName].records, missingFunc(tableName));
        });
    };
    exports.findMissingFiles = async (manifest) => {
        const missing = {};
        const { tables } = manifest;
        const missingTableFunc = markFileMissing(missing);
        await checkTablesForMissing(config_1.default.getSourcePath(), tables, missingTableFunc);
        return missing;
    };
});
