var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "path", "./config"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chunkArr = exports.wait = exports.getParsedFilesPayload = exports.parseFileNameParams = void 0;
    const path_1 = __importDefault(require("path"));
    const config_1 = __importDefault(require("./config"));
    async function _getConfigFromPath(params) {
        try {
            let curManifest = config_1.default.getManifest();
            if (!curManifest) {
                throw new Error("No Manifest file");
            }
            const { tableName, name } = params;
            const { tables, scope } = curManifest;
            const { records } = tables[tableName];
            let sys_id = "";
            if (records.hasOwnProperty(name)) {
                sys_id = records[name].sys_id;
                if (!fieldExists(records[name], params)) {
                    throw new Error(`${params.targetField} not found in the manifest for ${records[name].name}`);
                }
                return Object.assign({}, params, { scope: scope, sys_id: sys_id });
            }
            else {
                throw new Error(`Cannot find record called ${name} in ${tableName}`);
            }
        }
        catch (e) {
            return;
        }
    }
    function fieldExists(record, context) {
        let matches = record.files.filter(cur => {
            return cur.name === context.targetField;
        });
        return matches.length === 1;
    }
    function getExtension(filePath) {
        try {
            let ext = "." +
                path_1.default
                    .basename(filePath)
                    .split(".")
                    .slice(1)
                    .join(".");
            return ext;
        }
        catch (e) {
            return "";
        }
    }
    async function parseFileNameParams(filePath) {
        const ext = getExtension(filePath);
        const resourcePath = path_1.default.dirname(filePath).split(path_1.default.sep);
        const resources = resourcePath.slice(-3);
        let targetField = path_1.default.basename(filePath, ext);
        const tableName = resources[1];
        const name = resources[2];
        if (tableName === "sys_atf_step")
            targetField = "inputs.script";
        return await _getConfigFromPath({
            filePath,
            tableName,
            name,
            targetField,
            ext
        });
    }
    exports.parseFileNameParams = parseFileNameParams;
    async function getParsedFilesPayload(arr) {
        let results = [];
        for (let file of arr) {
            let res = await parseFileNameParams(file);
            if (res) {
                results.push(res);
            }
        }
        return results;
    }
    exports.getParsedFilesPayload = getParsedFilesPayload;
    function wait(ms) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, ms);
        });
    }
    exports.wait = wait;
    function chunkArr(arr, chunkSize) {
        const numChunks = Math.ceil(arr.length / chunkSize);
        const chunks = [];
        for (let i = 0; i < numChunks; i++) {
            const rangeBegin = i * chunkSize;
            const rangeEnd = rangeBegin + chunkSize > arr.length ? arr.length : rangeBegin + chunkSize;
            chunks.push(arr.slice(rangeBegin, rangeEnd));
        }
        return chunks;
    }
    exports.chunkArr = chunkArr;
});
