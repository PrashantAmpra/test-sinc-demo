var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "axios", "./genericUtils", "./PluginManager", "./Logger", "./config", "progress"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const axios_1 = __importDefault(require("axios"));
    const genericUtils_1 = require("./genericUtils");
    const PluginManager_1 = __importDefault(require("./PluginManager"));
    const Logger_1 = require("./Logger");
    const config_1 = __importDefault(require("./config"));
    const progress_1 = __importDefault(require("progress"));
    const axiosConfig = {
        withCredentials: true,
        auth: {
            username: process.env.SN_USER || "",
            password: process.env.SN_PASSWORD || ""
        },
        headers: {
            "Content-Type": "application/json"
        },
        baseURL: `https://${process.env.SN_INSTANCE}/`
    };
    const api = axios_1.default.create(axiosConfig);
    const WAIT_TIME = 500;
    const CHUNK_SIZE = 10;
    const NETWORK_RETRIES = 3;
    const TABLE_API = "api/now/table";
    const NETWORK_TIMEOUT = 3000;
    async function _update(obj) {
        try {
            return await api(obj);
        }
        catch (e) {
            throw e;
        }
    }
    async function pushUpdate(requestObj) {
        try {
            if (requestObj && requestObj.data) {
                return _update(requestObj);
            }
            Logger_1.logger.error("Attempted to push an empty data object");
        }
        catch (e) {
            throw e;
        }
    }
    exports.pushUpdate = pushUpdate;
    async function pushUpdates(arrOfResourceConfig) {
        await arrOfResourceConfig.map(pushUpdate);
    }
    exports.pushUpdates = pushUpdates;
    async function getManifestWithFiles(scope, creds) {
        let endpoint = `api/x_nuvo_sinc/sinc/getManifestWithFiles/${scope}`;
        try {
            const { includes = {}, excludes = {}, tableOptions = {} } = config_1.default.getConfig();
            let response;
            if (creds) {
                let client = getBasicAxiosClient(creds);
                response = await client.post(endpoint, {
                    includes,
                    excludes,
                    tableOptions
                });
            }
            else {
                response = await api.post(endpoint, { includes, excludes, tableOptions });
            }
            return response.data.result;
        }
        catch (e) {
            throw e;
        }
    }
    exports.getManifestWithFiles = getManifestWithFiles;
    async function getManifest(scope) {
        let endpoint = `api/x_nuvo_sinc/sinc/getManifest/${scope}`;
        try {
            const { includes = {}, excludes = {}, tableOptions = {} } = config_1.default.getConfig();
            let response = await api.post(endpoint, {
                includes,
                excludes,
                tableOptions
            });
            return response.data.result;
        }
        catch (e) {
            throw e;
        }
    }
    exports.getManifest = getManifest;
    async function getMissingFiles(missingFiles) {
        let endpoint = `api/x_nuvo_sinc/sinc/bulkDownload`;
        try {
            const { tableOptions = {} } = config_1.default.getConfig();
            const payload = { missingFiles, tableOptions };
            let response = await api.post(endpoint, payload);
            return response.data.result;
        }
        catch (e) {
            throw e;
        }
    }
    exports.getMissingFiles = getMissingFiles;
    async function pushATFfile(file, sys_id) {
        let endpoint = `api/x_nuvo_sinc/sinc/pushATFfile`;
        try {
            let payload = { file, sys_id };
            let response = await api.post(endpoint, payload);
            return response;
        }
        catch (e) {
            throw e;
        }
    }
    function buildFileEndpoint(payload) {
        const { tableName, sys_id } = payload;
        return [TABLE_API, tableName, sys_id].join("/");
    }
    async function buildFileRequestObj(target_server, filePayload, processFile = true) {
        try {
            const url = buildFileEndpoint(filePayload);
            const fileContents = await PluginManager_1.default.getFinalFileContents(filePayload, processFile);
            const { targetField } = filePayload;
            let data = {};
            data[targetField] = fileContents;
            if (filePayload.tableName === "sys_atf_step")
                data = fileContents;
            return { url, data, method: "PATCH" };
        }
        catch (e) {
            throw e;
        }
    }
    async function pushFiles(target_server, filesPayload, processFile = true) {
        const resultSet = [];
        let progBar;
        if (Logger_1.logger.getLogLevel() === "info") {
            progBar = new progress_1.default(":bar :current/:total (:percent)", {
                total: filesPayload.length,
                width: 60
            });
        }
        let chunks = genericUtils_1.chunkArr(filesPayload, CHUNK_SIZE);
        Logger_1.logger.silly(`${chunks.length} chunks of ${CHUNK_SIZE}`);
        for (let chunk of chunks) {
            let resultsPromises = chunk.map(ctx => {
                const pushPromise = pushFile(target_server, ctx, processFile);
                pushPromise
                    .then(() => {
                    if (progBar) {
                        progBar.tick();
                    }
                })
                    .catch(() => {
                    if (progBar) {
                        progBar.tick();
                    }
                });
                return pushPromise;
            });
            const results = await Promise.all(resultsPromises);
            resultSet.push(...results);
            await genericUtils_1.wait(WAIT_TIME);
        }
        return resultSet;
    }
    exports.pushFiles = pushFiles;
    async function pushFile(target_server, fileContext, processFile = true, devMode = false, retries = 0) {
        const fileSummary = `${fileContext.tableName}/${fileContext.name}(${fileContext.sys_id})`;
        if (fileContext.sys_id && fileContext.targetField) {
            try {
                let requestObj = await buildFileRequestObj(target_server, fileContext, processFile);
                let response = fileContext.tableName === "sys_atf_step"
                    ? await pushATFfile(requestObj.data, fileContext.sys_id)
                    : await pushUpdate(requestObj);
                Logger_1.logger.debug(`Attempting to push ${fileSummary}`);
                if (response) {
                    if (response.status === 404) {
                        Logger_1.logger.error(`Could not find ${fileSummary} on the server.`);
                        return false;
                    }
                    if (response.status < 200 || response.status > 299) {
                        Logger_1.logger.error(`Failed to push ${fileSummary}. Recieved an unexpected response (${response.status})`);
                        if (devMode || retries === NETWORK_RETRIES) {
                            Logger_1.logger.debug(JSON.stringify(response, null, 2));
                        }
                        throw new Error();
                    }
                    Logger_1.logger.debug(`${fileSummary} pushed successfully!`);
                    return true;
                }
                Logger_1.logger.error(`No response object ${fileSummary}`);
                return false;
            }
            catch (e) {
                Logger_1.logger.error(`Failed to push ${fileSummary}`);
                if (!devMode && retries < NETWORK_RETRIES) {
                    Logger_1.logger.info(`Retrying to push ${fileSummary}. Retries: ${retries + 1}`);
                    await genericUtils_1.wait(NETWORK_TIMEOUT);
                    return await pushFile(target_server, fileContext, processFile, devMode, retries + 1);
                }
                else {
                    Logger_1.logger.info(`Maximum retries reached for ${fileSummary}`);
                    console.error(e);
                    throw new Error();
                }
            }
        }
        Logger_1.logger.error(`Failed to push ${fileSummary}, missing either a target field or sys_id`);
        return false;
    }
    exports.pushFile = pushFile;
    async function deployFiles(target_server, filesPayload) {
        return await pushFiles(target_server, filesPayload, false);
    }
    exports.deployFiles = deployFiles;
    async function getCurrentScope() {
        let endpoint = "api/x_nuvo_sinc/sinc/getCurrentScope";
        try {
            let response = await api.get(endpoint);
            return response.data.result;
        }
        catch (e) {
            throw e;
        }
    }
    exports.getCurrentScope = getCurrentScope;
    async function getAppList(creds) {
        try {
            let endpoint = "api/x_nuvo_sinc/sinc/getAppList";
            let response;
            if (creds) {
                let client = getBasicAxiosClient(creds);
                response = await client.get(endpoint);
            }
            else {
                response = await api.get(endpoint);
            }
            let apps = response.data.result;
            return apps;
        }
        catch (e) {
            throw e;
        }
    }
    exports.getAppList = getAppList;
    function getBasicAxiosClient(creds) {
        let serverString = creds.instance || "NO_INSTANCE";
        return axios_1.default.create({
            withCredentials: true,
            auth: {
                username: creds.user,
                password: creds.password
            },
            baseURL: `https://${serverString}/`
        });
    }
    async function swapServerScope(scopeId, updateSetName = "") {
        try {
            const userSysId = await getUserSysId();
            const curAppUserPrefId = await getCurrentAppUserPrefSysId(userSysId);
            // If not user pref record exists, create it.
            if (curAppUserPrefId !== "") {
                await updateCurrentAppUserPref(scopeId, curAppUserPrefId);
            }
            else {
                await createCurrentAppUserPref(scopeId, userSysId);
            }
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.swapServerScope = swapServerScope;
    async function getScopeId(scopeName) {
        try {
            const endpoint = "api/now/table/sys_scope";
            let response = await api.get(endpoint, {
                params: {
                    sysparm_query: `scope=${scopeName}`,
                    sysparm_fields: "sys_id"
                }
            });
            Logger_1.logger.debug(`getScopeId.response = ${JSON.stringify(response.data)}`);
            return response.data.result[0].sys_id;
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.getScopeId = getScopeId;
    async function getUserSysId(userName = process.env.SN_USER) {
        try {
            const endpoint = "api/now/table/sys_user";
            let response = await api.get(endpoint, {
                params: {
                    sysparm_query: `user_name=${userName}`,
                    sysparm_fields: "sys_id"
                }
            });
            return response.data.result[0].sys_id;
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.getUserSysId = getUserSysId;
    async function getCurrentAppUserPrefSysId(userSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference`;
            let response = await api.get(endpoint, {
                params: {
                    sysparm_query: `user=${userSysId}^name=apps.current_app`,
                    sysparm_fields: "sys_id"
                }
            });
            Logger_1.logger.debug(`getCurrentAppUserPrefSysId.response = ${JSON.stringify(response.data)}`);
            if (response.data.result.length > 0) {
                return response.data.result[0].sys_id;
            }
            else {
                return "";
            }
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.getCurrentAppUserPrefSysId = getCurrentAppUserPrefSysId;
    async function updateCurrentAppUserPref(appSysId, userPrefSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference/${userPrefSysId}`;
            await api.put(endpoint, { value: appSysId });
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.updateCurrentAppUserPref = updateCurrentAppUserPref;
    async function createCurrentAppUserPref(appSysId, userSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference`;
            await api.post(endpoint, {
                value: appSysId,
                name: "apps.current_app",
                type: "string",
                user: userSysId
            });
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.createCurrentAppUserPref = createCurrentAppUserPref;
    async function getCurrentUpdateSetUserPref(userSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference`;
            let response = await api.get(endpoint, {
                params: {
                    sysparm_query: `user=${userSysId}^name=sys_update_set`,
                    sysparm_fields: "sys_id"
                }
            });
            return response.data.result[0].sys_id;
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.getCurrentUpdateSetUserPref = getCurrentUpdateSetUserPref;
    async function updateCurrentUpdateSetUserPref(updateSetSysId, userPrefSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference/${userPrefSysId}`;
            await api.put(endpoint, { value: updateSetSysId });
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.updateCurrentUpdateSetUserPref = updateCurrentUpdateSetUserPref;
    async function createCurrentUpdateSetUserPref(updateSetSysId, userSysId) {
        try {
            const endpoint = `api/now/table/sys_user_preference`;
            await api.put(endpoint, {
                value: updateSetSysId,
                name: "sys_update_set",
                type: "string",
                user: userSysId
            });
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.createCurrentUpdateSetUserPref = createCurrentUpdateSetUserPref;
    async function createUpdateSet(updateSetName) {
        try {
            const endpoint = `api/now/table/sys_update_set`;
            const response = await api.post(endpoint, {
                name: updateSetName
            });
            return response.data.result.sys_id;
        }
        catch (e) {
            Logger_1.logger.error(e);
            throw e;
        }
    }
    exports.createUpdateSet = createUpdateSet;
});
