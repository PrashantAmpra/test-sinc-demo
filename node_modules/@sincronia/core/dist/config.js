var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "path", "fs", "./Logger", "./defaultOptions"], factory);
    }
})(function (require, exports) {
    "use strict";
    var __syncRequire = typeof module === "object" && typeof module.exports === "object";
    Object.defineProperty(exports, "__esModule", { value: true });
    const path_1 = __importDefault(require("path"));
    const fs_1 = require("fs");
    const Logger_1 = require("./Logger");
    const defaultOptions_1 = require("./defaultOptions");
    const DEFAULT_CONFIG = {
        sourceDirectory: "src",
        buildDirectory: "build",
        rules: [],
        includes: defaultOptions_1.includes,
        excludes: defaultOptions_1.excludes,
        tableOptions: {},
        refreshInterval: 30
    };
    let ConfigManager = new (class {
        constructor() { }
        async loadConfigs() {
            try {
                let noConfigPath = false; //Prevents logging error messages during init
                const config_path = await this.loadConfigPath();
                if (config_path)
                    this.config_path = config_path;
                else
                    noConfigPath = true;
                const root = await this.loadRootDir(noConfigPath);
                if (root)
                    this.root_dir = root;
                const config = await this.loadConfig(noConfigPath);
                if (config)
                    this.config = config;
                const env = await this.loadEnvPath();
                if (env)
                    this.env_path = env;
                const source = await this.loadSourcePath();
                if (source)
                    this.source_path = source;
                const build = await this.loadBuildPath();
                if (build)
                    this.build_path = build;
                const manifest_path = await this.loadManifestPath();
                if (manifest_path)
                    this.manifest_path = manifest_path;
                const manifest = await this.loadManifest();
                if (manifest)
                    this.manifest = manifest;
                const diff = await this.loadDiffPath();
                if (diff)
                    this.diff_path = diff;
                const diff_file = await this.loadDiffFile();
                if (diff_file)
                    this.diff_file = diff_file;
                const refresh = await this.loadRefresh();
                if (refresh)
                    this.refresh_interval = refresh;
            }
            catch (e) {
                throw e;
            }
        }
        getConfig() {
            if (this.config)
                return this.config;
            throw new Error("Error getting config");
        }
        getConfigPath() {
            if (this.config_path)
                return this.config_path;
            throw new Error("Error getting config path");
        }
        checkConfigPath() {
            if (this.config_path)
                return this.config_path;
            return false;
        }
        getRootDir() {
            if (this.root_dir)
                return this.root_dir;
            throw new Error("Error getting root directory");
        }
        getManifest(setup = false) {
            if (this.manifest)
                return this.manifest;
            if (!setup)
                throw new Error("Error getting manifest");
        }
        getManifestPath() {
            if (this.manifest_path)
                return this.manifest_path;
            throw new Error("Error getting manifest path");
        }
        getSourcePath() {
            if (this.source_path)
                return this.source_path;
            throw new Error("Error getting source path");
        }
        getBuildPath() {
            if (this.build_path)
                return this.build_path;
            throw new Error("Error getting build path");
        }
        getEnvPath() {
            if (this.env_path)
                return this.env_path;
            throw new Error("Error getting env path");
        }
        getDiffPath() {
            if (this.diff_path)
                return this.diff_path;
            throw new Error("Error getting diff path");
        }
        getDiffFile() {
            if (this.diff_file)
                return this.diff_file;
            throw new Error("Error getting diff file");
        }
        getRefresh() {
            if (this.refresh_interval)
                return this.refresh_interval;
            throw new Error("Error getting refresh interval");
        }
        getDefaultConfigFile() {
            return `
    module.exports = {
      sourceDirectory: "src",
      buildDirectory: "build",
      rules: [],
      excludes:{},
      includes:{},
      tableOptions:{},
      refreshInterval:30
    };
    `.trim();
        }
        async loadConfig(skipConfigPath = false) {
            if (skipConfigPath) {
                Logger_1.logger.warn("Couldn't find config file. Loading default...");
                return DEFAULT_CONFIG;
            }
            try {
                let configPath = ConfigManager.getConfigPath();
                if (configPath) {
                    let projectConfig = (await (__syncRequire ? Promise.resolve().then(() => __importStar(require(configPath))) : new Promise((resolve_1, reject_1) => { require([configPath], resolve_1, reject_1); }).then(__importStar))).default;
                    //merge in includes/excludes
                    let { includes: pIncludes = {}, excludes: pExcludes = {}, tableOptions: pTableOptions = {} } = projectConfig;
                    projectConfig.includes = Object.assign(defaultOptions_1.includes, pIncludes);
                    projectConfig.excludes = Object.assign(defaultOptions_1.excludes, pExcludes);
                    projectConfig.tableOptions = Object.assign(defaultOptions_1.tableOptions, pTableOptions);
                    return projectConfig;
                }
                else {
                    Logger_1.logger.warn("Couldn't find config file. Loading default...");
                    return DEFAULT_CONFIG;
                }
            }
            catch (e) {
                Logger_1.logger.warn(e);
                Logger_1.logger.warn("Couldn't find config file. Loading default...");
                return DEFAULT_CONFIG;
            }
        }
        async loadManifest() {
            try {
                let manifestString = await fs_1.promises.readFile(ConfigManager.getManifestPath(), "utf-8");
                return JSON.parse(manifestString);
            }
            catch (e) {
                return undefined;
            }
        }
        updateManifest(man) {
            this.manifest = man;
        }
        async loadConfigPath(pth) {
            if (!pth) {
                pth = process.cwd();
            }
            // check to see if config is found
            let files = await fs_1.promises.readdir(pth);
            if (files.includes("sinc.config.js")) {
                return path_1.default.join(pth, "sinc.config.js");
            }
            else {
                if (isRoot(pth)) {
                    return false;
                }
                return this.loadConfigPath(path_1.default.dirname(pth));
            }
            function isRoot(pth) {
                return path_1.default.parse(pth).root === pth;
            }
        }
        async loadRefresh() {
            let { refreshInterval = 30 } = ConfigManager.getConfig();
            return refreshInterval;
        }
        async loadSourcePath() {
            let rootDir = ConfigManager.getRootDir();
            let { sourceDirectory = "src" } = ConfigManager.getConfig();
            return path_1.default.join(rootDir, sourceDirectory);
        }
        async loadBuildPath() {
            let rootDir = ConfigManager.getRootDir();
            let { buildDirectory = "build" } = ConfigManager.getConfig();
            return path_1.default.join(rootDir, buildDirectory);
        }
        async loadEnvPath() {
            let rootDir = ConfigManager.getRootDir();
            return path_1.default.join(rootDir, ".env");
        }
        async loadManifestPath() {
            let rootDir = ConfigManager.getRootDir();
            return path_1.default.join(rootDir, "sinc.manifest.json");
        }
        async loadDiffPath() {
            let rootDir = ConfigManager.getRootDir();
            return path_1.default.join(rootDir, "sinc.diff.manifest.json");
        }
        async loadDiffFile() {
            try {
                let diffString = await fs_1.promises.readFile(ConfigManager.getDiffPath(), "utf-8");
                return JSON.parse(diffString);
            }
            catch (e) {
                return undefined;
            }
        }
        async loadRootDir(skip) {
            if (skip)
                return process.cwd();
            let configPath = ConfigManager.getConfigPath();
            if (configPath) {
                return path_1.default.dirname(configPath);
            }
            else {
                return process.cwd();
            }
        }
    })();
    exports.default = ConfigManager;
});
